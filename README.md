# Swisp
Lisp in Swift excercise
![](/dir.png)
* small, suitable for embedding
* atoms have value and function bindings
* lambdas are closures
* tail-recursion (at least the obvious cases...)
* macros
* backquote read macro
* "interpreted" but some expressions are "compiled" on the fly... (macroexpansions are memoized)
* bignum supported, can be typealised to Double if needed

Functions:
```
BUILTIN: % (X Y)
BUILTIN: * (X Y)
BUILTIN: + (X Y)
BUILTIN: - (X Y)
BUILTIN: / (X Y)
BUILTIN: < (X Y)
BUILTIN: <= (X Y)
BUILTIN: > (X Y)
BUILTIN: >= (X Y)
FUN: ADD (&REST LST)
BUILTIN: AND (A B)
FUN: APPEND (X Y)
BUILTIN: APPLY (FUN ARGS)
BUILTIN: ARGLIST (FUN)
FUN: ASSQ (X Y)
BUILTIN: ATOM (EXPR)
MACRO: BACKQUOTE (TEMPLATE)
FUN: BQ-COMMA (CODE)
MACRO: BQ-LIST* (&REST ARGS)
FUN: BQ-PROCESS (FORM)
FUN: BQ-PROCESS-1 (FLAG THING)
FUN: BQ-PROCESS-2 (CODE)
FUN: BQ-VECTOR-CONTENTS (VEC)
MACRO: CAAR (X)
MACRO: CADAR (X)
MACRO: CADR (X)
BUILTIN: CAR (EXPR)
MACRO: CASE (&REST BODY)
BUILTIN: CATCH (TAG EXPR)
MACRO: CDAR (X)
MACRO: CDDDR (X)
MACRO: CDDR (X)
BUILTIN: CDR (EXPR)
BUILTIN: CLOCK ()
BUILTIN: COND ((TEST1 . BODY1) ... (TESTN .BODYN))
BUILTIN: CONS (A B)
BUILTIN: CONSP (EXPR)
MACRO: DECF (VAR &OPTIONAL (VALUE 1))
MACRO: DEFCONST (VAR VAL)
SPECIAL: DEFMACRO (NAME PARAMS &REST BODY)
MACRO: DEFPARAMETER (VAR VAL)
SPECIAL: DEFSPECIAL (NAME PARAMS &REST BODY)
SPECIAL: DEFUN (NAME PARAMS &REST BODY)
MACRO: DEFVAR (VAR VAL)
FUN: DIV (A B)
MACRO: DOLIST (PARAMS &REST BODY)
MACRO: DOTIMES (PARAMS &REST BODY)
BUILTIN: EQ (A B)
FUN: EQUAL (X Y)
MACRO: ERROR (FORMAT &REST MSGS)
BUILTIN: EVAL (EXPR)
FUN: FACT (X)
FUN: FACTREC (X)
FUN: FILTER (F X)
MACRO: FIRST (X)
BUILTIN: FLET ((VAR1 (PARAM1 ...) . BODY1) ... (VARN (PARAMN ...) .BODYN))
BUILTIN: FLUSH (&OPTIONAL STREAM)
BUILTIN: FN ((PARAM ..) .BODY)
FUN: FOLDL (F E L)
FUN: FORMAT (STREAM FORMAT &REST ARGS)
BUILTIN: FUNCALL FUN (EXPR1 EXPR2 ... EXPRN)
BUILTIN: FUNCTION (EXPR)
BUILTIN: FUNP (EXPR)
BUILTIN: FUNSET (ATM FUN)
FUN: FUNTYPE (F)
BUILTIN: GENSYM (EXPR1 EXPR2 ... EXPRN)
BUILTIN: GETPROP (ATM PROP)
BUILTIN: IF (TEST THEN &OPTIONAL ELSE)
MACRO: INCF (VAR &OPTIONAL (VALUE 1))
BUILTIN: ISBUILTIN (EXPR)
BUILTIN: ISMACRO (EXPR)
BUILTIN: ISSPECIAL (EXPR)
BUILTIN: LAMBDA ((PARAM ..) .BODY)
FUN: LAST (L)
BUILTIN: LET ((VAR1 EXPR1) ... (VARN EXPRN))
BUILTIN: LET* ((VAR1 EXPR1) ... (VARN EXPRN))
FUN: LIST (&REST L)
FUN: LIST* (&REST L)
FUN: LIST-FUNS NIL
FUN: LISTGTE (A B)
FUN: LISTLESS (A B)
BUILTIN: MACRO ((PARAM ..) .BODY)
FUN: MAP (F X)
FUN: MAPF (F X)
FUN: MEMQ (A L)
FUN: MUL (&REST LST)
FUN: NCONC (&REST L)
BUILTIN: NLAMBDA ((PARAM ..) .BODY)
FUN: NOT (X)
FUN: NTH (I L)
FUN: NULL (X)
BUILTIN: NUMBERP (EXPR)
BUILTIN: OR (A B)
BUILTIN: PEEKCHAR (STREAM)
BUILTIN: PRINT (EXPR1 EXPR2 ... EXPRN)
BUILTIN: PROGN (EXPR1 EXPR2 ... EXPRN)
FUN: PROVIDE (LIB)
FUN: PUTPROP (PROPS KEY VAL)
FUN: QSORT (L)
BUILTIN: QUOTE (EXPR)
BUILTIN: READ (&OPTIONAL STREAM)
BUILTIN: READFILE (STREAM)
BUILTIN: READMACRO (STREAM FUN)
FUN: REQUIRE (LIB PATH)
MACRO: REST (X)
FUN: REVERSE (X)
BUILTIN: RPLACA (ATM VALUE)
BUILTIN: RPLACD (ATM VALUE)
MACRO: SECOND (X)
FUN: SET-MACRO-CHARACTER (C FUN)
BUILTIN: SETQ (ATM EXPR ...)
BUILTIN: SKIPCHAR (STREAM)
BUILTIN: STRFORMAT (FMT EXPR1 ...)
BUILTIN: STRINGP (EXPR)
FUN: SUB (A B)
BUILTIN: SYMBOL-TABLE ()
MACRO: THIRD (X)
BUILTIN: THROW (TAG EXPR)
MACRO: TIME (EXPR)
FUN: TOPLOOP NIL
BUILTIN: UNCLOSURE (ATM)
MACRO: UNLESS (CONDITION &REST BODY)
BUILTIN: UNSTR (STR)
FUN: VECTORP (EXPR)
MACRO: WHEN (TEST &REST BODY)
BUILTIN: WHILE (TEST .BODY)
```
